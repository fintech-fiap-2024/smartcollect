name: CI/CD do Projeto SmartCollect

# O pipeline é disparado sempre que houver um push na branch 'main'
on:
  push:
    branches:
      - main

env:
  # Nome da Imagem no Docker Hub - Use seu nome de usuário em minúsculas
  DOCKER_IMAGE_NAME: geovani237/smartcollect-esg
  DOCKER_REGISTRY: docker.io
  TAG: ${{ github.sha }}

jobs:
  # 1. BUILD E TESTES AUTOMATIZADOS (CI)
  build_and_test:
    name: Build e Testes com Maven (Oracle Integration)
    runs-on: ubuntu-latest

    # =========================================================================
    # SERVICE CONTAINERS: INICIA O ORACLE DB PARA TESTES DE INTEGRAÇÃO
    # O nome 'oracle-db' é o HOST resolvível para o Spring Boot
    # =========================================================================
    services:
      oracle-db:
        image: container-registry.oracle.com/database/free:latest
        ports:
          - 1521:1521/tcp
    steps:
      - name: Checkout do Código
        uses: actions/checkout@v4

      - name: Setup JDK 21 e Cache Maven
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'

      # CORREÇÃO FINAL: Espera Ativa, Captura de ID e Confirmação de Conexão
      - name: Esperar Oracle DB e Confirmar Conexão
        id: wait_db
        run: |
          echo "Testando conexão com o Oracle DB..."
          
          # 1. Captura o ID do contêiner real, necessário para o 'docker exec'
          # Usamos o nome de host 'oracle-db' para filtrar o ID.
          CONTAINER_ID=$(docker ps -aqf "name=oracle-db")
          
          if [ -z "$CONTAINER_ID" ]; then
            echo "Erro: Não foi possível encontrar o contêiner Docker 'oracle-db'."
            exit 1
          fi
          
          echo "Contêiner 'oracle-db' encontrado com ID: $CONTAINER_ID. Iniciando loop de conexão..."
          
          # Passa a senha do secret para uma variável shell para o docker exec
          ORACLE_PASS="${{ secrets.ORACLE_TEST_PASSWORD }}"
          
          # 2. Loop de espera ativa, usando o ID do contêiner
          for i in $(seq 1 40); do
            # O comando docker exec usa o ID capturado
            # Executa o sqlplus dentro do container, testando a conexão com 'localhost'.
            docker exec "$CONTAINER_ID" sh -c "sqlplus system/\${ORACLE_PASS}@//localhost:1521/FREEPDB1 -S <<< 'SELECT 1 FROM DUAL;'"
          
            # Verifica o código de saída do sqlplus
            if [ $? -eq 0 ]; then
              echo "Conexão com o banco de dados Oracle estabelecida com sucesso após $i tentativas."
              exit 0 
            fi
          
            echo "Tentativa $i falhou. Aguardando 6 segundos..."
            sleep 6
          done
          
          echo "Erro: Não foi possível conectar ao Oracle DB após múltiplas tentativas (timeout)."
          exit 1 

      - name: Executar Build e Testes (Conectando ao Oracle DB)
        env:
          # A URL APONTA PARA O NOME DO SERVIÇO: 'oracle-db'
          SPRING_DATASOURCE_URL: jdbc:oracle:thin:@oracle-db:1521/FREEPDB1
          SPRING_DATASOURCE_USERNAME: SYSTEM
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.ORACLE_TEST_PASSWORD }}
        run: mvn clean install

      - name: Upload JAR como Artefato
        uses: actions/upload-artifact@v4
        with:
          name: application-jar
          path: target/smartcollect-0.0.1-SNAPSHOT.jar

  # 2. BUILD E PUSH DA IMAGEM DOCKER
  build_push_docker:
    name: Build e Push da Imagem
    needs: build_and_test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do Código
        uses: actions/checkout@v4
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: application-jar
          path: target/
      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build e Push da Imagem
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest

  # 3. SIMULAÇÃO DE DEPLOY EM STAGING
  deploy_staging:
    name: Simulação de Deploy em Staging
    needs: build_push_docker
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Acessar Docker Registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Simulação de Deploy
        run: |
          echo "Simulando a conexão ao servidor de STAGING..."
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          echo "Deploy do ambiente STAGING concluído com sucesso."

  # 4. SIMULAÇÃO DE DEPLOY EM PRODUÇÃO (Com Aprovação Manual)
  deploy_production:
    name: Simulação de Deploy em Produção
    needs: deploy_staging
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://smartcollect.simulacao.com

    steps:
      - name: Acessar Docker Registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Simulação de Deploy
        run: |
          echo "SIMULANDO APROVAÇÃO MANUAL PARA PRODUÇÃO..."
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          echo "DEPLOY FINALIZADO! A aplicação SmartCollect está rodando em produção."